# CS-230-OperatingPlatforms
Portfolio for Operating Platforms class
**Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?**
The Gaming Room is a startup that presently creates games for Android smartphones, but they hope to expand into developing web-based applications as well. Their initial program is a game called "Draw It, or Lose It" that can be played in a web browser and on a variety of operating systems.
**What did you do particularly well in developing this documentation?**
Design guidelines, a software domain model, and considerations for each operating system that the game would be developed and run on make up the paperwork for this project. The ultimate objective was to offer development suggestions keeping each of these factors in mind, and the domain model would have been the most helpful in this regard to help developers comprehend precisely how the functionality of the game should work. Design guidelines, a software domain model, and considerations for each operating system that the game would be developed and run on make up the paperwork for this project. The ultimate objective was to offer development suggestions keeping each of these factors in mind, and the domain model would have been the most helpful in this regard to help developers comprehend precisely how the functionality of the game should work. Design guidelines, a software domain model, and considerations for each operating system that the game would be developed and run on make up the paperwork for this project. The ultimate objective was to offer development suggestions keeping each of these factors in mind, and the domain model would have been the most helpful in this regard to help developers comprehend precisely how the functionality of the game should work.
**What about the process of working through a design document did you find helpful when developing the code?**
The team's ability to direct their work while keeping the client's objectives and values in mind is made possible by the creation of a software design document, which serves as a central repository for goals and data relating to the development of the application. It was especially helpful in that it could be referred to at any time for guidance and provides answers to many potential questions.
**If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?**
The design restrictions are the section of the document that I would change. I didn't realize all the factors that must be taken into account while implementing the software on various platforms. I would have expanded on the server restrictions here, such as using REST API best practices.
**How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?**
Since there is already an application that meets the needs of the user, I concentrated on ensuring that it is available on all platforms and optimizing its performance. The benefit of REST API-based web-connected servers is that they may interface with a wide range of platforms to obtain the data they want via HTTP. All of the customer's wants must be taken into account in order to deliver the greatest product. This aids in creating a system that maximizes functionality while adhering to the client's preferences.
**How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?**
There are many approaches to designing software, and the specific techniques and strategies used can depend on a variety of factors, such as the type of software being developed, the intended audience, the resources available, and the constraints of the project.
One common approach to designing software is to use a systematic method, such as the waterfall model or the agile software development methodology. These methods involve a series of steps or stages, such as gathering requirements, designing the architecture, implementing the code, and testing the software.
In the future, when analyzing and designing a similar software application, I would follow a similar process, which might include the following steps:

Gather requirements: This involves understanding the needs of the users and stakeholders, and defining the goals and objectives of the software.
Analyze the problem: This involves identifying the problems that the software will solve and the challenges that it will face.
Design the architecture: This involves creating a high-level design of the software, including the overall structure and the relationships between different components.
Implement the code: This involves writing the code to implement the software according to the design.
Test the software: This involves verifying that the software works as intended and meets the requirements.
Deploy the software: This involves making the software available to the users and ensuring that it is properly installed and configured.

Throughout this process, it is important to regularly communicate with the stakeholders, to ensure that the software meets their needs and that any changes or modifications are properly coordinated. It is also important to be flexible and adaptable, as the requirements and constraints of a software project can often change during the development process.



